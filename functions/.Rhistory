library(BDgraph)
seed = 22111996
p <- 40
set.seed(seed)
adj <- graph.sim( p = p, graph = "cluster", class=3 , vis=T)
adj
set.seed(seed)
K_true <- rgwish(n = 1, adj = adj)
n <- 300
set.seed(seed)
beta_true <- rmvnorm(n=n, mean = rep(0, length=p), sigma=solve(K_true))
# Costruzione matrice phi
r <- 200
x <- seq(0, 1, length.out=r)
basis <- create.bspline.basis(rangeval=range(x), nbasis=40, norder=3)
BaseMat <- eval.basis(x, basis) # matrix r x p
library(fda)
library(BDgraph)
library(fda)
seed = 22111996
p <- 40
set.seed(seed)
adj <- graph.sim( p = p, graph = "cluster", class=3 , vis=T)
adj
set.seed(seed)
K_true <- rgwish(n = 1, adj = adj)
n <- 300
set.seed(seed)
beta_true <- rmvnorm(n=n, mean = rep(0, length=p), sigma=solve(K_true))
# Costruzione matrice phi
r <- 200
x <- seq(0, 1, length.out=r)
basis <- create.bspline.basis(rangeval=range(x), nbasis=40, norder=3)
BaseMat <- eval.basis(x, basis) # matrix r x p
tau_eps = 100
cov_y <- tau_eps * diag(1, r, r)
y_hat_true = matrix(nrow = n, ncol = r)
for (i in c(1:n)){
mean_y <- as.vector(BaseMat%*%beta_true[i, ])
y_hat_true[i, ] <- rmvnorm(n=1, mean=mean_y, sigma=cov_y)
}
plot(x, y_hat_true[1, ], type='l')
setwd("C:/Users/Asus/OneDrive - Politecnico di Milano/Università/Magistrale/SECONDO ANNO/Bayesian Statistics/Project/Codici")
BaseMat_path = "C:/Users/Asus/OneDrive - Politecnico di Milano/Università/Magistrale/SECONDO ANNO/Bayesian Statistics/Project/Codici/BaseMat.cvs"
y_hat_true_path = "C:/Users/Asus/OneDrive - Politecnico di Milano/Università/Magistrale/SECONDO ANNO/Bayesian Statistics/Project/Codici/y_hat_true.cvs"
write.csv(BaseMat, file = BaseMat_path, row.names = FALSE)
write.csv(y_hat_true, file = y_hat_true_path, row.names = FALSE)
y_hat_true_path = "C:/Users/Asus/OneDrive - Politecnico di Milano/Università/Magistrale/SECONDO ANNO/Bayesian Statistics/Project/Codici/y_hat_true.csv"
library(BDgraph)
library(fda)
seed = 22111996
p <- 40
# Simulate a block graph
set.seed(seed)
adj <- graph.sim( p = p, graph = "cluster", class=3 , vis=T)
adj
# Simulate the precision matrix given the graph
set.seed(seed)
K_true <- rgwish(n = 1, adj = adj)
# Simulate the beta coefficients given the precision matrix
n <- 300
set.seed(seed)
beta_true <- rmvnorm(n=n, mean = rep(0, length=p), sigma=solve(K_true))
# Build the phi matrix
r <- 200
x <- seq(0, 1, length.out=r)
basis <- create.bspline.basis(rangeval=range(x), nbasis=40, norder=3)
BaseMat <- eval.basis(x, basis) # matrix r x p
# Simulate the functional data
tau_eps = 100
cov_y <- tau_eps * diag(1, r, r)
y_hat_true = matrix(nrow = n, ncol = r)
for (i in c(1:n)){
mean_y <- as.vector(BaseMat%*%beta_true[i, ])
y_hat_true[i, ] <- rmvnorm(n=1, mean=mean_y, sigma=cov_y)
}
x11()
plot(x, y_hat_true[1, ], type='l')
# Save data in a cvs
BaseMat_path = "C:/Users/Asus/OneDrive - Politecnico di Milano/Università/Magistrale/SECONDO ANNO/Bayesian Statistics/Project/Codici/BaseMat.csv"
y_hat_true_path = "C:/Users/Asus/OneDrive - Politecnico di Milano/Università/Magistrale/SECONDO ANNO/Bayesian Statistics/Project/Codici/y_hat_true.csv"
write.csv(BaseMat, file = BaseMat_path, row.names = FALSE)
write.csv(y_hat_true, file = y_hat_true_path, row.names = FALSE)
library(BDgraph)
library(fda)
seed = 22111996
p <- 40
# Simulate a block graph
set.seed(seed)
adj <- graph.sim( p = p, graph = "cluster", class=3 , vis=T)
adj
# Simulate the precision matrix given the graph
set.seed(seed)
K_true <- rgwish(n = 1, adj = adj)
# Simulate the beta coefficients given the precision matrix
n <- 300
set.seed(seed)
beta_true <- rmvnorm(n=n, mean = rep(0, length=p), sigma=solve(K_true))
# Build the phi matrix
r <- 200
x <- seq(0, 1, length.out=r)
basis <- create.bspline.basis(rangeval=range(x), nbasis=40, norder=3)
BaseMat <- eval.basis(x, basis) # matrix r x p
# Simulate the functional data
tau_eps = 100
cov_y <- tau_eps * diag(1, r, r)
y_hat_true = matrix(nrow = n, ncol = r)
for (i in c(1:n)){
mean_y <- as.vector(BaseMat%*%beta_true[i, ])
y_hat_true[i, ] <- rmvnorm(n=1, mean=mean_y, sigma=cov_y)
}
x11()
plot(x, y_hat_true[1, ], type='l')
# Save data in a cvs
BaseMat_path = "C:/Users/Asus/OneDrive - Politecnico di Milano/Università/Magistrale/SECONDO ANNO/Bayesian Statistics/Project/Codici/BaseMat.csv"
y_hat_true_path = "C:/Users/Asus/OneDrive - Politecnico di Milano/Università/Magistrale/SECONDO ANNO/Bayesian Statistics/Project/Codici/y_hat_true.csv"
write.csv(BaseMat, file = BaseMat_path, row.names = FALSE)
write.csv(y_hat_true, file = y_hat_true_path, row.names = FALSE)
knitr::opts_chunk$set(echo = TRUE)
BaseMat = read_csv('BaseMat.csv')
shhh = function(lib_name){ # It's a library, so shhh!
suppressWarnings(suppressMessages(require(lib_name, character.only = TRUE)))
}
shhh("tidyverse")
shhh("ACutils")
shhh("mvtnorm")
shhh("salso")
shhh("FGM")
shhh("gmp")
shhh("mcclust")
shhh("mcclust.ext")
shhh("logr")
shhh("tidygraph")
shhh("ggraph")
shhh("igraph")
shhh("Rcpp")
shhh("RcppArmadillo")
shhh("RcppEigen")
## Load custom functions
source("utility_functions.R");source("bulky_functions.R");source("data_generation.R")
sourceCpp("wade.cpp")
Rcpp::sourceCpp('UpdateParamsGSL.cpp')
gc()
install.packages(c("DBI", "digest", "expm", "fastmatrix", "FNN", "glue", "ks", "patchwork", "pkgload", "plotly", "ps", "Rcpp", "RCurl", "readr", "rlang", "roxygen2", "timechange", "uuid", "withr"))
knitr::opts_chunk$set(echo = TRUE)
# Import simulated data
BaseMat = as.matrix(read_csv('BaseMat.csv'))
shhh = function(lib_name){ # It's a library, so shhh!
suppressWarnings(suppressMessages(require(lib_name, character.only = TRUE)))
}
shhh("tidyverse")
shhh("ACutils")
shhh("mvtnorm")
shhh("salso")
shhh("FGM")
shhh("gmp")
shhh("mcclust")
shhh("mcclust.ext")
shhh("logr")
shhh("tidygraph")
shhh("ggraph")
shhh("igraph")
shhh("Rcpp")
shhh("RcppArmadillo")
shhh("RcppEigen")
## Load custom functions
source("utility_functions.R");
source("bulky_functions.R");
source("data_generation.R")
sourceCpp("wade.cpp")
Rcpp::sourceCpp('UpdateParamsGSL.cpp')
library('RcppGSL')
library(fda)
library(tidyverse)
# Import simulated data
BaseMat = as.matrix(read_csv('BaseMat.csv'))
y_hat_true = as.matrix(read_csv('y_hat_true.csv'))
n <- dim(y_hat_true)[1]
r <- dim(y_hat_true)[2]
p <- dim(BaseMat)[2]
# Define the starting matrix with error
Beta = matrix(rnorm(n = p*n), nrow = p, ncol = n)
# Define the starting value of mu with error
mu = rnorm(n=p)
# Fix tau_eps (squared)
tau_eps = 100
# Define the precision matrix K
K = rWishart(n = 1, df = p+10, Sigma = diag(p))
K = K[,,1]
# ACutils::ACheatmap(K,center_value = NULL, remove_diag = T)
tbase_base = t(BaseMat)%*%BaseMat # p x p (phi_t * phi)
tbase_data = t(BaseMat)%*%t(y_hat_true) # p x n (phi_t * Y_t)  mettiamo insieme tutti i beta, verranno estratte le colonne nel file C
Sdata = sum(diag(y_hat_true%*%t(y_hat_true))) # inefficient calculation ((2b + Sdata) è il b di tau_eps a posteriori) qui mette phi*beta = 0 come inizializz.
# Set True binary flag used to update values
Update_Beta <- TRUE
Update_Mu <- TRUE
Update_Tau <- TRUE
a_tau_eps <- 2000
b_tau_eps <- 2
sigma_mu = 100
# Define variance of the Beta
beta_sig2 = 0.2
# Compute graph density
graph_density = 0.3
# Set the number of iterations
niter <- 10000
# Create a list for chains
chains <- list(
Beta = vector("list", length = niter),
mu = vector("list", length = niter),
tau_eps = vector("list", length = niter),
K = vector("list", length = niter),
G = vector("list", length = niter),
z = vector("list", length = niter),
rho = vector("list", length = niter),
time = vector("list", length = niter)
)
# Initialization of the chains
chains$Beta[[1]] <- Beta
chains$mu[[1]] <- mu
chains$tau_eps[[1]] <- tau_eps
chains$K[[1]] <- K
chains$G[[1]] <- diag(1,p,p)
chains$z[[1]] <- rep(1,p)
chains$time <- 0
chains$rho[[1]] <- p
sigma <-0.5
theta<-1
weights_a <- rep(1,p-1)
weights_d <- rep(1,p-1)
total_weights <- 0
total_K = matrix(0,p,p)
total_graphs = matrix(0,p,p)
graph_start = NULL
for(s in 2:10000) {
fit = UpdateParamsGSL(
chains$Beta[[s-1]],
chains$mu[[s-1]],
chains$tau_eps[[s-1]],
chains$K[[s-1]],
tbase_base,
tbase_data,
Sdata,
a_tau_eps,
b_tau_eps,
sigma_mu,
r,
Update_Beta,
Update_Mu,
Update_Tau
)
# Save Beta
chains$Beta[[s]] <- fit$Beta
# Save mu
chains$mu[[s]] <- fit$mu
# Save tau
chains$tau_eps[[s]] <- fit$tau_eps
# Set options for a single iteration of the Gibbs_sampler
options = set_options(
sigma_prior_0=sigma,
sigma_prior_parameters=list("a"=1,"b"=1,"c"=1,"d"=1),
theta_prior_0=theta,
theta_prior_parameters=list("c"=1,"d"=1),
rho0=chains$rho[[s-1]],    # start with one group
weights_a0=weights_a,
weights_d0=weights_d,
total_weights0=total_weights,
total_K0 = total_K,
total_graphs0 = total_graphs,
graph = graph_start,
alpha_target=0.234,
beta_mu=graph_density,   # da modificare (expected value beta distr of the graph)
beta_sig2=beta_sig2,     # da modificare (var beta distr del grafo, fra 0 e 0.25)
d=3,                     # param della G wishart (default 3)
alpha_add=0.5,
adaptation_step=1/(p*1000),
update_sigma_prior=TRUE,
update_theta_prior=TRUE,
update_weights=TRUE,
update_partition=TRUE,
update_graph=TRUE,
perform_shuffle=TRUE
)
# Run an iteration of the Gibbs Sampler
res <- Gibbs_sampler(
data = t(fit$Beta - fit$mu),
niter = 1, # niter finali, già tolto il burn in
nburn = 0,
thin = 1,
options = options,
seed = 22111996,
print = FALSE
)
z = do.call(rbind, lapply(res$rho, rho_to_z))
# Save rho
chains$rho[[s]] <- res$rho[[1]]
# Save K
chains$K[[s]] <- res$K [[1]]
# Save G
chains$G[[s]] <- res$G [[1]]   # primo valore NULL o identità
# Save z
chains$z[[s]] <- z      # primo valore NULL o mettiamo tutti 1
# Save times for each K
chains$time[[s]] <- res$execution_time
# Update quantities for the next iteration
# weights
weights_a <- res$weights_a
weights_d <- res$weights_d
total_weights <- res$total_weights
total_K <- res$total_K [[1]]
total_graphs <- res$total_graphs [[1]]
# graph
graph_start = res$bdgraph_start
}
shhh = function(lib_name){ # It's a library, so shhh!
suppressWarnings(suppressMessages(require(lib_name, character.only = TRUE)))
}
shhh("tidyverse")
shhh("ACutils")
shhh("mvtnorm")
shhh("salso")
shhh("FGM")
shhh("gmp")
shhh("mcclust")
shhh("mcclust.ext")
shhh("logr")
shhh("tidygraph")
shhh("ggraph")
shhh("igraph")
shhh("Rcpp")
shhh("RcppArmadillo")
shhh("RcppEigen")
## Load custom functions
source("functions/utility_functions.R");
source("functions/bulky_functions.R");
source("functions/data_generation.R")
sourceCpp("functions/wade.cpp")
Rcpp::sourceCpp('functions/UpdateParamsGSL.cpp')
library('RcppGSL')
library(fda)
library(tidyverse)
# Import simulated data
BaseMat = as.matrix(read_csv('simulated_data/BaseMat.csv'))
y_hat_true = as.matrix(read_csv('simulated_data/y_hat_true.csv'))
n <- dim(y_hat_true)[1]
r <- dim(y_hat_true)[2]
p <- dim(BaseMat)[2]
setwd("C:/Users/Asus/OneDrive - Politecnico di Milano/Università/Magistrale/SECONDO ANNO/Bayesian Statistics/Project/Codici/bayesian-statistics-project/functions")
